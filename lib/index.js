"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CSharpLanguage {
    constructor(profile, definition, options) {
        this.profile = profile;
        this.definition = definition;
        this.options = options;
    }
    /**
     * Generates a file header based on the Swagen profile and definition details.
     * @returns {string[]} A string array of the lines in the generated header
     */
    buildHeader() {
        const header = [
            `// ------------------------------`,
            `// <auto-generated>`,
            `//     Generated using the Swagen tool`,
            `//     Generator: ${this.profile.generator}`,
        ];
        if (this.profile.mode) {
            header.push(`//     Mode: ${this.profile.mode}`);
        }
        header.push(`// </auto-generated>`, `// ------------------------------`);
        if (this.definition && this.definition.metadata) {
            if (this.definition.metadata.title) {
                header.push(`// ${this.definition.metadata.title}`);
            }
            if (this.definition.metadata.description) {
                header.push(`// ${this.definition.metadata.description}`);
            }
            if (this.definition.metadata.baseUrl) {
                header.push(`// Base URL: ${this.definition.metadata.baseUrl}`);
            }
        }
        return header;
    }
    buildOperationDocComments(operation) {
        const comments = [];
        if (operation.description) {
            comments.push(`/// ${operation.description}`);
        }
        if (operation.description2) {
            comments.push(`/// ${operation.description2}`);
        }
        if (comments.length > 0) {
            comments.unshift(`/// <summary>`);
            comments.push(`/// </summary>`);
        }
        const describedParams = (operation.parameters || [])
            .filter(p => !!p.description)
            .map(p => `/// <param name="${p.name}">${p.description}</param>`);
        comments.push(...describedParams);
        return comments;
    }
    getDataType(property, skipPrefix = false) {
        let typeName;
        if (property.primitive) {
            typeName = this.getPrimitiveTypeName(property);
        }
        else if (property.complex) {
            typeName = this.prefixNamespace(property.complex, skipPrefix);
        }
        else if (property.enum) {
            typeName = this.prefixNamespace(property.enum, skipPrefix);
        }
        else {
            throw new Error(`Cannot understand type of property in definition: ${JSON.stringify(property, null, 4)}`);
        }
        if (!property.isArray) {
            return typeName;
        }
        switch (this.options.collectionType || 'IReadOnlyList') {
            case 'IReadOnlyList': return `IReadOnlyList<${typeName}>`;
            case 'Array': return `${typeName}[]`;
            case 'IList': return `IList<${typeName}>`;
            default: throw new Error(`Unrecognized collection type - ${this.options.collectionType}.`);
        }
    }
    getPrimitiveTypeName(property) {
        switch (property.primitive) {
            case 'integer':
                switch (property.subType) {
                    case 'int32':
                        return 'int';
                    case 'int64':
                        return 'long';
                    default:
                        return 'int';
                }
            case 'number':
                return property.subType || 'double';
            case 'string': {
                switch (property.subType) {
                    case 'date-time':
                    case 'date':
                        return 'DateTime';
                    case 'uuid':
                    case 'byte':
                    case 'password':
                        return 'string';
                    default:
                        return 'string';
                }
            }
            case 'boolean':
                return 'bool';
            case 'file':
            case 'object':
                return 'object';
            case 'array':
                return 'object[]';
            default:
                throw new Error(`Cannot translate primitive type ${JSON.stringify(property, null, 4)}`);
        }
    }
    prefixNamespace(name, skipPrefix) {
        return skipPrefix ? name : `__models.${name}`;
    }
    getMethodSignature(operationName, operation, options) {
        const accessor = options.visibility ? options.visibility + ' ' : '';
        const parameters = (operation.parameters || []).reduce((accumulate, parameter) => {
            if (accumulate) {
                accumulate += ', ';
            }
            accumulate += `${parameter.name}: ${this.getDataType(parameter.dataType)}`;
            return accumulate;
        }, '');
        let returnType = this.getReturnType(operation);
        if (typeof options.returnTypeFormatter === 'function') {
            returnType = options.returnTypeFormatter(returnType);
        }
        const methodSig = `${accessor} ${returnType} ${operationName}(${parameters})`;
        return methodSig;
    }
    getReturnType(operation) {
        if (!operation.responses) {
            return 'void';
        }
        for (const statusKey in operation.responses) {
            if (operation.responses.hasOwnProperty(statusKey)) {
                const statusCode = +statusKey;
                if (statusCode >= 200 && statusCode < 300 && operation.responses[statusKey].dataType) {
                    return this.getDataType(operation.responses[statusKey].dataType);
                }
            }
        }
        return 'void';
    }
}
exports.CSharpLanguage = CSharpLanguage;
